---
title: "Starter Notebook"
author: "You, Scientist"
format: html
execute:
  keep-md: true
---

```{r}
#Load in any packages you need
library(tidyverse)

#Read in any data

```

```{r}
instructors <- c("Duryea", "Gilbert")

instructors
```

Challenge 1: List of nucleotides

```{r}
nucleotides <- c("A", "G","C","T")
nucleotides
```

The code block combines the strings of the four nucleotides into the variable nucleotides and then prints it out.

Challenge 2: Random string of 15 nucleotides

```{r}
numNucleotide <- 15

randGenome <- sample(nucleotides, size = numNucleotide, replace = TRUE)

randGenome
```

A length of a genome is set at 15 with the variable numNucleotide. The variable randGenome is sampled (randomized) with the size of 15. Randgenome is printed out.

Challenge 3

```{r}
numNucleotide <- 1500

randGenome <- sample(nucleotides, size = numNucleotide, replace = TRUE)

randGenome <- paste(randGenome, collapse ="")

randGenome

```

The length of nucleotides is set at 1500. The only difference between this and challenge 2 is that string is collapsed to display a sequence of letters instead of the full names (adenosine, guanine, thymine, cytosine).

Challenge 4: Generate a random genome of 100 nucleotides and count adenosine

```{r}
set.seed(215)
numNucleotide <- 100

randGenome <- sample(nucleotides, size = numNucleotide, replace = TRUE)

randGenome <- paste(randGenome, collapse ="")

randGenome
```

Challenge 5:

```{r}
myProduct <- 1

for(j in 1:15){
  myProduct <- myProduct + j
  print(myProduct)
}


```

Creates a for loop where it runs through the variable j 15 times and whatever number it produces is added to myProduct

## Challenge 6

```{r}
#Use this code chunk to complete Challenge 6
genomeLength <- 20
randGenome <- sample(nucleotides, size = genomeLength, replace = TRUE)
randGenome <- paste(randGenome, collapse = "")
randGenome
  for(j in 1:10){
  print(str_sub(randGenome, start = j, end = j))
}

```

Setting the genome length to 20, we create a randomized sample based on the length and collapse the string to the letters A,G,C,T. We create a for loop for randGenome that is printed 10 times.

## Challenge 7

```{r}
randGenome
Adenine_count <- 0
for (i in 1:nchar(randGenome)){
  if(str_sub(randGenome, start = i, end = i) == "A"){
    Adenine_count <- Adenine_count + 1
    print(Adenine_count)
}
}
```

Using the for loop from challenge six, we have the code look for the string "A" or adenine in the genome and add it to a variable called Adenine count. We then print out the final adenine count.

```{r}
randGenome
Adenine_count <- 0
Thymine_count <- 0
Guanine_count <- 0
Cytosine_count <- 0
for (i in 1:nchar(randGenome)){
  if(str_sub(randGenome, start = i, end = i) == "A"){
    Adenine_count <- Adenine_count + 1
}
  if(str_sub(randGenome,start = i, end = i) == "G"){
      Guanine_count <- Guanine_count + 1
  }
  if(str_sub(randGenome, start = i, end = i) == "C"){
    Cytosine_count <- Cytosine_count + 1
  }
  if(str_sub(randGenome, start = i, end = i) == "T"){
    Thymine_count <- Thymine_count+1
}
  print(c(Cytosine_count,Thymine_count,Guanine_count,Adenine_count))
  }      


```

The only options are AGCT. Nothing else is possible. We are already guaranteening we are covering all the conditions. If your can split the data into a dichotomy: else is otherwise instead of restrictive. This expands on challenge 7 but adds in a frequency for the other nucleotides as well. The final print statement combines all the variables together.

## Challenge 9

```{r}
vib_c <- scan("C:/Users/Joshua/OneDrive - SNHU/Desktop/Classes Spring 2023/Bioinformatics/VibrioCholerae.txt", what = "character", sep = NULL)
vib_c
Adenine_count <- 0
Thymine_count <- 0
Guanine_count <- 0
Cytosine_count <- 0
for (i in 1:nchar(vib_c)){
  if(str_sub(vib_c, start = i, end = i) == "A"){
    Adenine_count <- Adenine_count + 1
}
  if(str_sub(vib_c,start = i, end = i) == "G"){
      Guanine_count <- Guanine_count + 1
  }
  if(str_sub(vib_c, start = i, end = i) == "C"){
    Cytosine_count <- Cytosine_count + 1
  }
  if(str_sub(vib_c, start = i, end = i) == "T"){
    Thymine_count <- Thymine_count+1
}
} 
print(c(Cytosine_count,Thymine_count,Guanine_count,Adenine_count))

```

Using the code from challenge 8, we import the genome of a cholera bacteria and produce an output that returns the frequency of the nucleotides.

## Challenge 10

```{r}
rosalind <- "AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC"
rosalind
Adenine_count <- 0
Thymine_count <- 0
Guanine_count <- 0
Cytosine_count <- 0
for (i in 1:nchar(rosalind)){
  if(str_sub(rosalind, start = i, end = i) == "A"){
    Adenine_count <- Adenine_count + 1
}
  if(str_sub(rosalind,start = i, end = i) == "G"){
      Guanine_count <- Guanine_count + 1
  }
  if(str_sub(rosalind, start = i, end = i) == "C"){
    Cytosine_count <- Cytosine_count + 1
  }
  if(str_sub(rosalind, start = i, end = i) == "T"){
    Thymine_count <- Thymine_count+1
}
} 
print(c(Cytosine_count,Thymine_count,Guanine_count,Adenine_count))
```

```{r}
rosalind <- scan("C:/Users/Joshua/OneDrive - SNHU/Desktop/Classes Spring 2023/Bioinformatics/rosalind_dna.txt", what = "character", sep = NULL)
rosalind
Adenine_count <- 0
Thymine_count <- 0
Guanine_count <- 0
Cytosine_count <- 0
for (i in 1:nchar(rosalind)){
  if(str_sub(rosalind, start = i, end = i) == "A"){
    Adenine_count <- Adenine_count + 1
}
  if(str_sub(rosalind,start = i, end = i) == "G"){
      Guanine_count <- Guanine_count + 1
  }
  if(str_sub(rosalind, start = i, end = i) == "C"){
    Cytosine_count <- Cytosine_count + 1
  }
  if(str_sub(rosalind, start = i, end = i) == "T"){
    Thymine_count <- Thymine_count+1
}
} 
print(c(Cytosine_count,Thymine_count,Guanine_count,Adenine_count))
```

# Origin of Replication

## Challenge 1

The goal of this challenge is to generate a random string of 2000 nucleotides and use the function command to count the frequency of cytosine in the genome string.

```{r}
nucleotide_frequency <- function(genomeString, nucleotide = "A"){
  count <- 0
  for(i in 1:nchar(genomeString)){
    if(str_sub(genomeString, start = i, end = i) == nucleotide){
      count <- count + 1
    }
  }
  return(count)
}

nucleotide_frequency("ACTTGCGGGTATCGAG", "G")
```

    nucleotide_frequency <- function(genomeString, nucleotide = "A"){
      count <- 0
      for(i in 1:nchar(genomeString)){
        if(str_sub(genomeString, start = i, end = i) == nucleotide){
          count <- count + 1
        }
      }
      return(count)
    }

    nucleotide_frequency("ACTTGCGGGTATCGAG", "G")

```{r}

genomeLength <- 2000
randGenome <- sample(nucleotides, size = genomeLength, replace = TRUE)

nucleotide_frequency <- function(randGenome, nucleotides = "C"){
  count <- 0
  for(i in 1:nchar(randGenome)){
    if(str_sub(randGenome, start = i, end = i) == nucleotides){
      count <- count + 1
    }
  }
  return(count)
}

randGenome <- paste(randGenome, collapse = "")
nucleotide_frequency(randGenome, "C")
```

My first attempt was to set the variable genomeLength to 2000. From there I created a random sample based on 2000 nucleotides. Then I created a function that counted the amount of cytosines and then returned a count. The problem is that when I returned my function, I only returned the string in nucleotide frequency (ACGT...ACGT) instead of the variable randGenome. Furthermore, I did not condense the list of nucleotides into a number (i.e the count of cytosine) using the paste function.

## Challenge 2

Build a function `rand_genome()` which takes a single parameter `k`, denoting the number of nucleotides in the genome we wish to generate. Your function should return a single genome string of length k.

```{r}
rand_Genome <- function(genomeString, nucleotides){
    nucleotides <- c("A", "G","C","T")
    rand_Genome <- sample(nucleotides, size = genomeString, replace = TRUE)
    
rand_Genome <- paste(rand_Genome, collapse = "")
print(rand_Genome)}

rand_genome <- rand_Genome(2000, nucleotides)
```

My initial logic was to create a sample function for randGenome where genomelength was set as k. Then I would run a function that would determine genomelength by running a for loop that looks for k and then adds it to the count. I would then paste a collapsed version of the text to produce a count of the genomelength. However the output produces just a string of non-randomized text and wont let me collapse the randGenome.

Turns out the for loop was not necessary. We would be defining the size of the genome length through the variable genomeString.

## Challenge 3

```{r}
generate_3_mers <- function(genomeString){
  #list to hold 3-mers
  list_3_mers <- c()
  
  #run throguh genome and append 3-mers to list
  for(i in 1:(nchar(genomeString) - 2)){
    list_3_mers <- list_3_mers%>%
      append(str_sub(genomeString, start = i, end = i + 2))
  }
  #return list of 3-mers
  return(list_3_mers)
    
}

generate_3_mers(rand_genome)
```

For this challenge, I incorporated the ideas of the for loop and function to collect nucleotides in triplets (threemers) in a string of 2000. In the last function, I defined the list of nucleotides as rand_genome which included a set length (determined by genomestring) and nucleotides (which contained the substrings A,C,G,T to represent the nucleotides). For my new function, I input the argument genomestring (which would run whatever length I defined in the last code block).

Then I defined a list as list_3\_mers as c(). This empty vector would collect three nucleotides in sets to be outputted later. I then created a for loop to run through the entirety of the genomestring (I defined the length in the last code block as 2000). The command i in 1:nchar would run through the entire genomestring regardless of its length. The -2 would ensure that there were no cutoffs and each nucleotide set was in a triplet/threemer. Every for loop would save to the vector list_3\_mers (list_3\_mers \<- list_3\_mers%\>%) and through the append function would take the substrings of genomestring (a,c,g,t) and add 2 to whatever substring to form a triplet. With the for loop run, I returned the list of 3mers.

With the function complete, the final step was to run it with the rand_genome. While the genome string gives us a length, it does not include the specific nucleotides. For that reason, I input the argument rand_genome to run through the entire genome.

The main problem I had with this challenge was due to my coding in the last challenge. At the end of the block, I defined rand_genome but forgot to save the command for reuse by writing rand_genome \<- rand_genome(2000, nucleotides). With that simple fix the code gave the desired output.

## Challenge 4

```{r}
generate_k_mers <- function(genomeString, k){
  #list to hold 3-mers
  list_k_mers <- c()
  
  #run throguh genome and append 3-mers to list
  for(i in 1:(nchar(genomeString) - (k-1))){
    list_k_mers <- list_k_mers%>%
      append(str_sub(genomeString, start = i, end = i + (k-1)))
  }
  #return list of 3-mers
  return(list_k_mers)
    
}

my_genome <- rand_Genome(10)
generate_k_mers(my_genome,8)
```

## Challenge 5

```{r}
count_pattern <- function(genomeString, pattern){
  count <- 0
  for(i in nchar(genomeString)){
    if(str_sub(genomeString, start = i, end = i+1) == pattern){
      count = count + 1
    }
  }
  return(count)
}

count_pattern(genomeString, "TGCACCAA")
```

## Challenge 6
